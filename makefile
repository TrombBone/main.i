# «Фиктивные» цели
.PHONY: all clean

# Объектные файлы
OBJS_LIB = sort.o
OBJS_APP = main.o

# Файл библиотеки
# Действует соглашение: файл библиотеки <mylib> имеет имя lib<mylib>.a
MYLIBNAME = lib.a

# Файл программы
MYAPPNAME = a.out

AR = riscv64-unknown-elf-ar.exe
CC = riscv64-unknown-elf-gcc.exe

# Чтобы достичь цели «all», требуется построить библиотеку
all: $(MYLIBNAME) $(MYAPPNAME)

# Чтобы достичь цели «clean», требуется удалить созданные при сборке файлы
# - объектные файлы
# - файлы зависимостей
# - файл библиотеки
clean:
	$(RM) –f $(OBJS_LIB)
	$(RM) –f $(OBJS_APP)
	$(RM) –f $(OBJS_LIB:.o=.d)
	$(RM) –f $(OBJS_APP:.o=.d)
	$(RM) –f $(MYLIBNAME)
	$(RM) –f $(MYAPPNAME)

# Параметры компиляции
CFLAGS= -std=c11 –pedantic –Wall –O1

# Включаемые файлы следует искать в каталоге «include»
INCLUDES+= -I ./include

# Make должна искать файлы *.h в каталогах include и src
vpath %.h include src
# …, а файлы *.c – в каталоге src
vpath %.c src

# Рецепт построения файла библиотеки из имеющихся объектных файлов
# значением переменной $@ будет имя файла библиотеки
# значением переменной $^ будет список (с пробелом в качестве символа-разделителя) зависимостей
# (с удаленными дубликатами), в данном случае – список объектных файлов
$(MYLIBNAME): $(OBJS_LIB)
	$(AR) –rsc $@ $^

# Рецепт построения объектного файла из исходного текста
# значением переменной $< будет имя первого файла в списке зависимостей, в данном случае – имя исходного файла
%.o: %.c
	gcc –MD $(CFLAGS) $(INCLUDES) –c –o $@ $<

# Включаем всю имеющуюся информацию о зависимостях
# Лидирующий «-« означает, что отсутствие файла .d не является ошибкой
-include $(OBJS_LIB:.o=.d)

$(MYAPPNAME): $(OBJS_APP) $(MYLIBNAME)
	gcc –o $@ $^

-include $(OBJS_APP:.o=.d)